require_relative 'raw_spell.rb'
require_relative 'methods.rb'
#Take the format which spells are written in the player's hand book, and format them into ruby code.

#Set spell list so we know what we're looking for. Code generated by the spell_sphere_loader.

spell_list = ['Bless', 'Combine', 'Detect Evil', 'Purify Food & Drink', 'Atonement', 'Animal Friendship', 'Invisibility to Animals', 'Locate Animals or Plants', 'Charm Person or Mammal', 'Messenger', 'Snake Charm', 'Speak With Animals', 'Hold Animal', 'Summon Insects', 'Animal Summoning I', 'Call Woodland Beings', 'Giant Insect', 'Repel Insects', 'Animal Growth', 'Animal Summoning II', 'Animal Summoning III', 'Anti-Animal Shell', 'Geeping Doom', 'Plane Shift', 'Astral Spell', 'Command', 'Remove Fear', 'Enthrall', 'Hold Person', 'Cloak of Bravery', 'Free Action', 'Imbue With Spell Ability', 'Quest', 'Cumfusion', 'Exaction', 'Magical Stone', 'Shillelagh', 'Chant', 'Spiritual Hammer', 'Prayer', 'Flame Strike', 'Insect Plague', 'Holy Word', 'Create Food & Water', 'Animate Object', 'Blade Barrier', 'Heroes’ Feast', 'Wall of Thorns', 'Changestaff', 'Chariot of Sustarre', 'Detect Magic', 'Detect Poison', 'Detect Snares & Pits', 'Locate Animals or Plants', 'Augury', 'Detect Charm', 'Find Traps', 'Know Alignment', 'Speak With Animals', 'Locate Object', 'Speak With Dead', 'Detect Lie', 'Divination', 'Reflecting Pool', 'Tongues', 'Commune', 'Commune With Nature', 'Magic Font', 'True Seeing', 'Find the Path', 'Speak With Monsters', 'Create Water', 'Dust Devil', 'Fire Trap', 'Flame Blade', 'Heat Metal', 'Produce Flame', 'Flame Walk', 'Meld Into Stone', 'Protections From Fire', 'Pyrotechnics', 'Stone Shape', 'Water Breathing', 'Water Walk', 'Lower Water', 'Produce Fire', 'Air Walk', 'Spike Stones', 'Transmute Rock to Mud', 'Wall of Fire', 'Conjure Fire Elemental', 'Fire Seeds', 'Part Water', 'Stone Tell', 'Transmute Water to Dust', 'Animate Rock', 'Chariot of Sustarre', 'Conjure Earth Elemental', 'Earthquake', 'Fie Storm', 'Transmute Metal to Wood', 'Wind Walk', 'Silence, 15’ Radius', 'Wyvern Watch', 'Glyph of Warding', 'Blade Barrier', 'Symbol', 'Cure Light Wounds', 'Slow Poison', 'Cure Serious Wounds', 'Neutralize Poison', 'Cure Critical Wounds', 'Heal', 'Invisibility to Undead', 'Aid', 'Animate Dead', 'Cure Blindness or Deafness', 'Cure Disease', 'Feign Death', 'Negative Plane Protection', 'Raise Dead', 'Regenerate', 'Reincarnate', 'Restoration', 'Resurrection', 'Entangle', 'Pass Without Trace', 'Shillelagh', 'Barkskin', 'Goodberry', 'Trip', 'Warp Wood', 'Plant Growth', 'Snare', 'Spike Growth', 'Tree', 'Hallucinatory Forest', 'Hold Plant', 'Plant Door', 'Speak With Plants', 'Sticks to Snakes', 'Anti-Plant Shell', 'Pass Plant', 'Liveoak', 'Transport Via Plants', 'Turn Wood', 'Wall of Thorns', 'Channestaff', 'Endure Cold/Endure Heat', 'Protection From Evil', 'sanctuary', 'Barkskin', 'Resist Fire/Resist Cold', 'Withdraw', 'Dispel Magic', 'Magical Vestment', 'Negative Plane Protection', 'Protection From Fire', 'Remove Curse', 'Remove Paralysis', 'Protection From Evil, 10\' Evil', 'Protection From Lightning', 'Repel Insects', 'SpeU Immunity', 'Anti-Plant Shell', 'Dispel Evil', 'Anti-Animal Shell', 'Abjure', 'Animal Summoning I', 'Call Woodland Beings', 'Animal Summoning I1', 'Dispel Evil', 'Aerial Servant', 'Animal Summoning I11', 'Animate Object', 'Conjure Animals', 'Wall of Thorns', 'Weather Summoning', 'Word of Recall', 'Conjure Earth Elemental', 'Creeping Doom', 'Exaction', 'Gate', 'Succor', 'Light', 'Continual Light', 'Starshine', 'Moonbeam', 'Rainbow', 'Sunray', 'Faerie Fire', 'Obscurement', 'Call Lightning', 'Control Temperature, 10\' Radius', 'Protection From Lightning', 'Control Winds', 'Rainbow', 'Weather Summoning', 'Control Weather']

#Set default values for all spells to none. That way, if nothing is listed, information will remain accurate
spell_name = "none"
spell_level = 1
sphere = "none"
range = "none"
components = "none"
material_component = "none"
duration = "none"
casting_time = "none"
area_of_effect = " none"
saving_throw = "error"
description = "none"


#spell_template = "#{spell_variable} = { \n \t spell_name: #{spell_name}, \n \t spell_level: #{spell_level}, \n \t sphere: #{sphere}, \n \t range: #{range}, \n \t components: #{components}, \n \t material_component: #{material_component}, \n \t duration: #{duration}, \n \t casting_time: #{casting_time}, \n \t area_of_effect: #{area_of_effect}, \n \t saving_throw: #{saving_throw}, \n \t description: #{description} \n}"

sphere_name = "none"
first = Array.new
second = Array.new
third = Array.new
fourth = Array.new
fifth = Array.new
sixth = Array.new
seventh = Array.new
eighth = Array.new
ninth = Array.new

sphere_template = "#{sphere_name} = { \n \t first: #{first}, \n \t second: #{second}, \n \t third: #{third}, \n \t fourth: #{fourth}, \n \t fifth: #{fifth}, \n \t sixth: #{sixth}, \n \t seventh: #{seventh}, \n \t eighth: #{eighth}, \n \t ninth: #{ninth} \n }"

#Sorting algorithm
=begin
$descript_sort.split("")
spell_book = Array.new

spell_list.each_with_index {|spell, item|
  sort = $descript_sort.split("#{spell}")

  #book.push(sort)
  
  sort.each_with_index {|check|
    #puts "#{spell_list[item]}"
    unless item == spell_list.count
      if check.include? "#{spell_list[item + 1]}"
        #Head empty
        spell_block = check.split("#{spell_list[item + 1]}")
        spell_book.push(spell_block[0])
      end
    end
  }
  
}
puts spell_list.count #=> 199
puts spell_book.count #=> 183
=end
=begin
  Our final product has less spells than the spell list. So, I believe this means the spell list is spelled differently than how it appears in descript_sort

Keep this in mind, but continue to extract the spell name from descript_sort. Then we can determine which spells are missing and adjust appropriately.
=end

=begin
  spell_list is not in the same order as descript_sort. The description extraction method I had before should ensure I return only the spell block I'm looking at, making order unimportant.
=end
spell_book = Array.new
missing = Array.new
effect_misspell = Array.new
effect_misspell_context = Array.new

spell_list.each_with_index {|spell, item|

  spell_variable = Array.new

  
  sort = $descript_sort.split("#{spell}")
  sort[1]
  #Old code beyond this point. Work needs done to integrate it.

  unless sort[1] == nil
    spellcount = sort[1].split("Area of Effect:")
    
    unless spellcount[1] == nil
    spell_split = spellcount[1]
    
    effect = spell_split.split("\n")
    area_of_effect = effect[0]
  
  saving_throw_grab = spell_split.split("Saving Throw:")
  #puts spell
    
  spell_template = "#{spell_variable} = { \n \t spell_name: #{spell_name}, \n \t spell_level: #{spell_level}, \n \t sphere: #{sphere}, \n \t range: #{range}, \n \t components: #{components}, \n \t material_component: #{material_component}, \n \t duration: #{duration}, \n \t casting_time: #{casting_time}, \n \t area_of_effect:#{area_of_effect}, \n \t saving_throw: #{saving_throw}, \n \t description: #{description} \n}"
  
  #puts spell_template


  saving_throw_grab.each_with_index {|save, correct|
    
    if correct == 1
      #puts "save output #{save}"
      effect = save.split("\n")
      saving_throw = effect[0]
      effect.shift()
      effect.shift()
      $together = " "
      effect.each {|des|

        $together = $together + des + " "
        $grabspell = Array.new
      }
      
        description = $together
    
        material = $together.split("The material components of this spell are")
        material = material[1]
      
        unless material == nil
          
          material = material.split(".")
          material_component = material[0]
          
        else
          material_component = "None"
        end
        
  spell_name = spell
  spell_peices = spell_name.downcase
  spell_peices = spell_peices.split(" ")
  spell_peices.each_with_index {|spell_peice, last|

    unless spell_peices.count == last + 1
      spell_variable.push("#{spell_peice}" + "_")
    else 
      spell_variable.push("#{spell_peice}")
    end
  }
  
  spell_variable = spell_variable.join
      
        spell_template = "#{spell_variable} = { \n \t spell_name: #{spell_name}, \n \t spell_level: #{spell_level}, \n \t sphere: #{sphere}, \n \t range: #{range}, \n \t components: #{components}, \n \t material_component:#{material_component}, \n \t duration: #{duration}, \n \t casting_time: #{casting_time}, \n \t area_of_effect:#{area_of_effect}, \n \t saving_throw:#{saving_throw}, \n \t description:#{description} \n}"
    
      puts "Spell template output \n #{spell_template}"
      spell_book.push(spell_template)
    end
  }
    else 
      effect_misspell.push("#{spellcount}")
      effect_misspell_context.push("#{sort[0]}")
    end
  else 
    missing.push("#{spell}")
  end
}

puts effect_misspell
puts effect_misspell_context
#Error occured due to "Quest" being a spell. Ruby found "Questioned" and returned 'ioned'
puts spell_list.count
puts spell_book.count
puts missing

#Don't forget to change any spell misspellings in spell_sphere_loader.rb as well
